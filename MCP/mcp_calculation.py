import numpy as np
from tqdm import tqdm
from sklearn.neighbors import NearestNeighbors


def compute_MCP(umap_2d, umap_1d, nb_neigh):
    
    # Import data
    pos = np.loadtxt(umap_2d) # position 2D UMAP
    col = np.loadtxt(umap_1d) # color 1D UMAP

    # Normalize color values between 0 and 100
    col = 100 * (col - col.min()) / (col.max() - col.min())

    MCP_depending_nb_neigh = []

    for n in nb_neigh:

        knn = NearestNeighbors(n_neighbors=n, metric='euclidean')
        knn.fit(pos)

        clusters = knn.kneighbors(pos, return_distance=False)

        diff_colors = []

        for cluster in tqdm((clusters), desc=f"considering {n} neighbors"):
            current, neighbors =  cluster[0], cluster[1:]
            current_col = col[current]
            median_neigh_col = np.median([col[neigh] for neigh in neighbors])
            diff_colors.append(abs(current_col - median_neigh_col))

        MCP_depending_nb_neigh.append(np.median(diff_colors))
        
        
    return MCP_depending_nb_neigh


# compute MCP values both before and after filtering potiential repackaged APKs
for name in ['before', 'after']:
    
    tags_projection = f'MCP/umap_projection_tags_{name}_filtering.txt'
    histograms_projection = f'MCP/umap_projection_histograms_{name}_filtering.txt'
    
    nb_neigh = [5, 10, 50, 100, 1000]
    
    print(f"\nComputing MCP {name} filtering :")
    
    MCP_depending_nb_neigh = compute_MCP(tags_projection, histograms_projection, nb_neigh)
    
    with open("MCP/MCP_values.txt", 'a') as f:
        f.write(f"Results {name} filtering :\n[Nb neighbors : MCP]\n")
        for (n, mcp) in zip(nb_neigh, MCP_depending_nb_neigh):
            f.write(f"{n} : {mcp:.2f}\n")
        f.write("\n\n")
        
        
print("\nResults can be found in MCP/MCP_values.txt")