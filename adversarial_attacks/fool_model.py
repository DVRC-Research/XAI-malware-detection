import os
import glob
import torch
import random
import argparse
import numpy as np
from PIL import Image
from tqdm import tqdm
from pathlib import Path
from helper import models
from torch import device, nn
import torch.nn.functional as F
import torchvision.transforms as transforms
from torchvision.transforms.functional import to_tensor


parser = argparse.ArgumentParser(
    description="Script to change the prediction of the model by altering the top-n most salient pixels",
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
)
parser.add_argument("-n", "--number_pixels", type=int, help="number of salient pixels to modify")
args = parser.parse_args()   


MODEL_NAME = "model_training/_models/DexrayOverTime5_classWeight_50epochs_lr_0.0001_p_0.3.pth"
IMG_SIZE = 128
DROPOUT = 0.3
BATCH_SIZE = 8
IMAGES_FOLDER = "_resized_img_128"
SALIENCY_FOLDER = "_all_saliency_maps"
NUMBER_PIXELS_CHANGED = args.number_pixels

# Setup
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

model = models.DexRayModel(IMG_SIZE, DROPOUT).to(device)
model.load_state_dict(torch.load(MODEL_NAME))

images_path = glob.glob(f"{IMAGES_FOLDER}/*/*/*.png")
saliencies_path = glob.glob(f"{SALIENCY_FOLDER}/*.png")


transform = transforms.Compose(
    [
        transforms.Grayscale(),
        transforms.ToTensor(),
        transforms.Lambda(lambda x: x.view(-1)),
    ]
)



def make_pred(image_path):
    
    image = Image.open(image_path)
    input_tensor = transform(image)
    input_batch = input_tensor.unsqueeze(0)
    input_batch = input_batch.to(device)

    model.eval()
    with torch.no_grad():
        output = model(input_batch)

    predicted = torch.sigmoid(output).squeeze() > 0.5
    
    return predicted.item()



def modify_top_n_pixels_and_predict(img_tensor, sal_tensor, model, n):

    idx_maximums = torch.argsort(sal_tensor, descending=True)[:n]
    flat_img_tensor = img_tensor.view(-1)

    for i in idx_maximums:
        new_val = torch.randint(0, 255, (1,)).float() / 255.0
        old_val = flat_img_tensor[i].item() * 255
        flat_img_tensor[i] = new_val

    input_batch = flat_img_tensor.unsqueeze(0).to(device)
    
    model.eval()
    with torch.no_grad():
        output = model(input_batch)
    predicted = torch.sigmoid(output).squeeze() > 0.5
    
    return predicted.item()



nb_fooled = 0
hashes_fooled = []

for i in tqdm(range(len(images_path)), desc="Trying to fool the model..."):

    image_path, saliency_path = images_path[i], saliencies_path[i]
    img = to_tensor(Image.open(image_path)).squeeze()
    sal = to_tensor(Image.open(saliency_path)).squeeze()

    original_pred = make_pred(image_path)

    fooled = False
    tries = 0

    while not fooled and tries<50:
        tries += 1
        pred = modify_top_n_pixels_and_predict(img.clone(), sal, model, NUMBER_PIXELS_CHANGED)

        if pred != original_pred:
            hashes_fooled.append(image_path)
            fooled = True
            nb_fooled += 1


file_name = Path(f"adversarial_attacks/model_fooled_{NUMBER_PIXELS_CHANGED}_pixels.txt")
file_name.parent.mkdir(parents=True, exist_ok=True)

with file_name.open("a") as file:
    file.write(f"Model fooled {nb_fooled} times over {len(images_path)} APKs\n")
    for hash in hashes_fooled:
        file.write(hash + "\n")
        
        
print(f"Experiment complete. Results can be found in {file_name}")