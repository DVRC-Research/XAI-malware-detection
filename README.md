# XAI-malware-detection

The aim of this work is to bring explainability to image-based Android malware detection.

## Requirements

To run the code you need to create a conda environment. You can do so by running the following commands after cloning the repository:

```bash
    conda env create --file ./conda-package-list.yml
    conda activate malware_detection_research
```

> üóíÔ∏è **Note** : we used Androguard 3.3.5 and not the version 4.0.2 because of a bug in the submodules not being recognized by PyLance.

```bash
    sudo apt-get update
    sudo apt-get install -y parallel
```


## How to run the code

This repository contains the code used for the experiments presented in [PAPER]
The usual workflow is:

### 1. Image conversion and model training

1. Insert the APKs in the `_dataset/unsorted` folder and provide a csv file containing the corresponding hashes, submission dates and VTD count. `_dataset/sorted.py` can be used to sort the apks dividing them into `train` and `test` folders depending on their first submission date, subdivided into `Goodware` and `Malware` depending on their VTD count.

2. Run `pre_processing/img_creation.sh` to transform the APKs into images and resize them. Here's an example on how to run the script:

   ```bash
   pre_processing/img_creation.sh
   ```

   This will create a `_resized_images_128` folder containing all successfully converted APKs for later usage. Potential errors will be stored in `pre_processing/conversion_errors.txt`.

3. Run `model_training/dexray.py` to train DexRay model on converted APKs. Learning rate and dropout probability can be specified and are set to 0.0001 and 0.3 respectively.

   ```bash
   python -m model_training.dexray
   ```

### 2. Analysis of the MCP

Run `MCP/launch_analysis.sh`. The script automates the 2D projection of APKs based on their tags and on the histogram of the corresponding image in 1D using `MCP/umap_projection.py`. The process is first performed for all the APKs and repeated after filtering out potential repackaged APKs. The script then calls `MCP/mcp_calculation.py` which saves MCP results in `MCP/MCP_values.txt`.


### 3. Find salient portions of code

1. Specify the hashes of the APKs you want to study in `pixel_to_code/wanted_apks.txt`. Make sure that all these APKs have already been converted to image in Step 2.

2. Execute `pixel_to_code/salient_code.sh` and specify an experiment name and the number of pixels you want to modify (default value set to 3). This code can be run as follows:
   ```bash
   pixel_to_code/salient_code.sh experiment_1 3
   ```
   The top 3 most salient portion of code would be stored in `pixel_to_code/salient_code/experiment_1.txt`


### 4. Adversarial attacks

Run `adversarial_attacks/fool_model.sh` to create all the saliency maps and **determine for how many APKs the model's decision is modified when modifying the top-n most salient pixels** of the original image. The default value for n is set to 3. Example:
   ```bash
   adversarial_attacks/fool_model.sh 3
   ```
   The results would be stored in `adversarial_attacks/model_fooled_3_pixels.txt`